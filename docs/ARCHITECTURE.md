# Архитектура и Ключевые Концепции Проекта

Этот документ описывает основные архитектурные принципы, структуру данных и логику работы проекта **TTRPG Character Builder**. Его цель — дать глубокое понимание, как и почему проект спроектирован именно так, чтобы обеспечить максимальную расширяемость и гибкость.

---

## 1. Фундаментальные Принципы

Наш проект строится на следующих ключевых принципах объектно-ориентированного дизайна (SOLID) и цели — поддержке множества игровых систем.

*   **S - Принцип Единственной Ответственности (Single Responsibility Principle - SRP):**
    *   Каждый модуль или класс отвечает только за одну конкретную область функциональности.
    *   **Применение:**
        *   **Модели (`models.py`):** Отвечают исключительно за описание структуры данных и их хранение в БД.
        *   **Сериализаторы (`serializers.py`):** Отвечают за преобразование данных между объектами Django и JSON, а также за их валидацию.
        *   **Сервисы (`services.py`):** Содержат всю бизнес-логику и сложные вычисления, не связанные напрямую с базами данных или HTTP-запросами.
        *   **Вьюсеты (`views.py`):** Отвечают за обработку HTTP-запросов и координацию работы сериализаторов и сервисов.

*   **O - Принцип Открытости/Закрытости (Open/Closed Principle - OCP):**
    *   Программные сущности должны быть открыты для расширения, но закрыты для изменения.
    *   **Применение:** Добавление новой игровой системы или Homebrew-контента не должно приводить к изменению существующего кода. Вместо этого мы добавляем новые данные (в виде JSON) в базу, а наш "Движок Правил" интерпретирует их. Это главный драйвер нашей архитектуры.

*   **L - Принцип Подстановки Барбары Лисков (Liskov Substitution Principle - LSP):**
    *   Объекты в программе должны быть заменяемы на экземпляры их подтипов без нарушения правильности выполнения программы.
    *   **Применение:** Мы используем универсальные родительские модели (`CharacterTrait` для классов/рас/происхождений, `EquipmentTemplate` для всех типов предметов), и дочерние элементы всегда могут быть обработаны логикой, ожидающей родительский тип.

*   **I - Принцип Разделения Интерфейса (Interface Segregation Principle - ISP):**
    *   Клиенты не должны зависеть от методов (интерфейсов), которые они не используют. Лучше много маленьких, специфичных интерфейсов, чем один большой и общий.
    *   **Применение:** Мы используем разные сериализаторы для разных действий (список, детальный просмотр, создание/обновление), что позволяет API отдавать только необходимую информацию.

*   **D - Принцип Инверсии Зависимостей (Dependency Inversion Principle - DIP):**
    *   Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
    *   **Применение:** Наши ViewSet'ы (верхний уровень) зависят не от конкретной логики Daggerheart, а от абстрактного "Движка Правил", который способен интерпретировать правила из данных. Это позволяет нам легко "подменять" игровую систему, не меняя основной код API.

---

## 2. Ключевые Архитектурные Компоненты

### 2.1. Модели Данных (Database Layer)

Это основа нашей расширяемости. Мы спроектировали универсальные модели, которые могут хранить данные для любой игровой системы.

*   **`GameSystem` (`core/models.py`):**
    *   Корневая модель. Каждая игровая система (Daggerheart, D&D 5e) представлена одной записью.
    *   Содержит основную мета-информацию о системе (`name`, `version`, `slug`).
    *   **Ключевая особенность:** В `metadata` этой модели будет храниться **`RulebookSchema`** – полное описание правил и формул системы (см. раздел 2.2).

*   **`TraitCategory` (`core/models.py`):**
    *   Определяет **тип** "строительного блока" персонажа в рамках конкретной системы.
    *   Примеры: "Class", "Ancestry" (для Daggerheart); "Race", "Background", "Class" (для D&D 5e).
    *   Эта модель позволяет нашей системе быть семантически гибкой.

*   **`CharacterTrait` (`core/models.py`):**
    *   **Универсальный "строительный блок" персонажа.** Представляет собой любую сущность, которую персонаж может "выбрать" или "получить" и которая влияет на его механики.
    *   Примеры: "Guardian" (класс), "Human" (происхождение), "Stalwart" (подкласс).
    *   Связан с `TraitCategory` (чтобы знать, это класс или раса).
    *   Имеет рекурсивную связь `parent` для иерархий (подклассы).
    *   Связан с `Features` через `ManyToManyField` (чтобы предоставлять способности).
    *   **Ключевая особенность:** Содержит `metadata` для системно-специфичных данных (например, `base_evasion` для класса Daggerheart, `hit_die` для класса D&D).

*   **`FeatureSet` (`core/models.py`):**
    *   Универсальный **контейнер для групп способностей**.
    *   Примеры: "Blade" (Домен Daggerheart), "School of Abjuration" (Школа магии D&D).
    *   Используется для организации и категоризации `Features`.

*   **`Feature` (`core/models.py`):**
    *   **Атомарная способность, особенность, черта или заклинание.** Это самый мелкий неделимый блок механики.
    *   Примеры: "Ночное зрение", "Огненный шар", "Божественный канал".
    *   Может быть связан с `FeatureSet`.
    *   **Ключевые особенности:**
        *   Поле `created_by`: Если заполнено, это пользовательский "Homebrew" контент (например, `Experience Tag` в Daggerheart), в противном случае — официальное правило системы.
        *   `metadata`: Хранит системно-специфичные правила для использования фичи (требования по уровню, стоимость в ресурсах, тип действия и т.д.).

*   **`DamageType` (`core/models.py`):**
    *   Описывает типы урона (Physical, Magical, Fire, Cold и т.д.). Используется для связей и фильтрации.

*   **`EquipmentTemplate` (`core/models.py`):**
    *   **Универсальный "шаблон" для любого предмета.** Это может быть оружие, броня, расходник, киберимплант, транспорт, запчасть для меха.
    *   **Ключевая особенность:** Содержит `metadata` для всех специфичных свойств предмета (тип предмета, урон, пороги брони, слоты инвентаря, требования к использованию и т.д.).

*   **`CharacterSheet` (`characters/models.py`):**
    *   Представляет **конкретный лист персонажа, питомца или NPC**.
    *   Связан с `GameSystem`, `User` (владелец).
    *   Имеет рекурсивную связь `controlled_by` для питомцев/компаньонов.
    *   Связан с `CharacterTrait` и `Feature` через `ManyToManyField` (все, что выбрано для персонажа).
    *   **Ключевые особенности:**
        *   `stats` (`JSONField`): Хранит все текущие и вычисляемые характеристики, ресурсы (HP, Stress, Hope), а также вычисляемые боевые параметры (Evasion, Damage Thresholds).
        *   `conditions` (`JSONField`): Список активных состояний персонажа.

*   **`CharacterEquipment` (`characters/models.py`):**
    *   Промежуточная модель для инвентаря. Связывает `CharacterSheet` с `EquipmentTemplate`.
    *   Содержит `quantity`, `location` (где предмет находится: "inventory", "equipped", "implanted").
    *   Имеет рекурсивную связь `parent_equipment` для модульных предметов (например, пушка установлена на мех).
    *   Содержит `metadata` для **уникального состояния** конкретного экземпляра предмета (например, оставшиеся пороги брони, заряды зелья).

### 2.2. Backend Services и "Движок Правил" (Rule Engine)

Это сердце нашей гибкости. Вместо того чтобы жестко кодировать логику в Python, мы будем хранить ее в `GameSystem.metadata` и исполнять с помощью универсального движка.

*   **`GameSystem.metadata.RulebookSchema`:**
    *   Это JSON-объект, который будет определять все правила конкретной игровой системы.
    *   Примеры секций:
        *   `character_sheet_schema`: Как вычислять `max_hp`, `evasion`, `armor_score`, `damage_thresholds` с помощью **строк-формул**.
        *   `available_actions`: Список всех игровых действий (например, `short_rest`, `level_up`), доступных в системе, и их **правила исполнения** (в виде списка команд).
        *   `trait_grants_features`: Какие фичи автоматически добавляются при выборе `CharacterTrait`.
    *   **Пример формулы:** `"trait('Class').metadata.base_hp + stats.level"`

*   **`core/engine/parser.py` и `core/engine/evaluator.py`:**
    *   Эти модули составят наш "Движок Правил".
    *   `parser`: Превращает строки-формулы из `RulebookSchema` в безопасные, исполняемые структуры (например, AST), **без использования опасного `eval()`**.
    *   `evaluator` (`RuleEvaluator`): Принимает персонажа и разобранную формулу/команду. Он умеет выполнять все разрешенные функции (`stats()`, `trait()`, `equipment()`, `stat_modifier()`) и математические операции, вычисляя результат.

*   **Универсальные Сервисы (`characters/services.py`):**
    *   **`CharacterStateService`:** Использует `RuleEvaluator` для **автоматического пересчета всех вычисляемых параметров** персонажа (из `character_sheet_schema`) при его создании или изменении.
    *   **`ActionExecutionService`:** Использует `RuleEvaluator` для **исполнения любого игрового действия** (например, "Короткий Отдых", "Повышение Уровня"), запрашиваемого через универсальный эндпоинт `POST /api/v1/sheets/{id}/perform_action/`. Он считывает правила действия из `GameSystem.metadata.available_actions` и применяет их к персонажу.
    *   **`FeatureGrantingService`:** Отвечает за автоматическую синхронизацию `character_sheet.features` при изменении `character_sheet.traits`, основываясь на `trait_grants_features` из `GameSystem.metadata`.

### 2.3. API Design (Django REST Framework)

*   Мы используем `Django REST Framework` для построения API.
*   **`ModelViewSet` и `ReadOnlyModelViewSet`:** Позволяют быстро создавать CRUD-операции для наших моделей.
*   **`Serializer` и вложенные сериализаторы:** Обеспечивают гибкое представление данных в JSON, включая рекурсивные структуры (подклассы, компаньоны).
*   **Кастомные Permissions:** Гарантируют безопасность данных (например, `IsOwner` для листов персонажей).
*   **Универсальные эндпоинты:** Вместо `short_rest` или `level_up` у нас будет один эндпоинт `perform_action`, который принимает тип действия в теле запроса (см. `ActionExecutionService`). Это делает API крайне гибким.
*   **Автоматическая документация (`drf-spectacular`):** Генерирует интерактивную спецификацию OpenAPI (Swagger UI), которая служит "контрактом" между бэкендом и фронтендом.

### 2.4. Frontend Philosophy (React)

*   **Data-Driven UI:** Фронтенд проектируется так, чтобы быть "слепым" к конкретной игровой системе. Вместо того чтобы иметь жесткие компоненты для "Характеристик Daggerheart", у него будут универсальные компоненты (`<StatsBlock />`), которые получают от бэкенда `GameSystem.metadata.character_sheet_schema` и на её основе динамически рендерят нужные поля.
*   Это позволяет фронтенду отображать любую систему, добавленную через бэкенд, без изменений в коде фронтенда.

### 2.5. Разработка и Качество Кода

*   **CI/CD:** GitHub Actions автоматически запускает линтеры (`flake8`) и форматтеры (`black --check`) при каждом Pull Request'е, гарантируя единый стиль и базовое качество кода.
*   **`pre-commit` хуки:** Локально форматируют и проверяют код перед коммитом, предотвращая попадание "грязного" кода в репозиторий.
*   **Тестирование:** Unit-тесты для сервисов и API, а также интеграционные тесты для проверки взаимодействия слоев.
